---
description: Form handling patterns with react-hook-form, validation, and error states
globs:
  - app/**/*.tsx
  - components/**/*.tsx
alwaysApply: false
---

# Form Handling

## React Hook Form

- Use `react-hook-form` for form management
- Use `@hookform/resolvers` with Zod for validation
- Register form fields using `register()` or `Controller`
- Use `handleSubmit` for form submission
- Handle loading and error states appropriately

## Form Structure

- Create controlled form components
- Use proper form elements (input, textarea, select)
- Associate labels with inputs using `htmlFor` and `id`
- Group related fields logically
- Provide clear validation feedback

```typescript
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useState } from "react";

const formSchema = z.object({
  prompt: z.string().min(1, "Prompt is required").max(2000, "Prompt too long"),
  negativePrompt: z.string().optional(),
  width: z.number().min(256).max(2048),
  height: z.number().min(256).max(2048),
});

type FormData = z.infer<typeof formSchema>;

export default function FormComponent() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      prompt: "",
      width: 1024,
      height: 1024,
    },
  });

  const onSubmit = async (data: FormData) => {
    setIsSubmitting(true);
    setError(null);

    try {
      // Handle form submission
      await submitForm(data);
      reset(); // Reset form on success
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Label htmlFor="prompt">Prompt</Label>
        <Input
          id="prompt"
          {...register("prompt")}
          className={errors.prompt ? "border-destructive" : ""}
        />
        {errors.prompt && (
          <p className="text-sm text-destructive mt-1">{errors.prompt.message}</p>
        )}
      </div>

      {/* More fields... */}

      {error && (
        <div className="text-destructive text-sm">{error}</div>
      )}

      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Submitting..." : "Submit"}
      </Button>
    </form>
  );
}
```

## Validation

- Use Zod schemas for validation
- Validate on submit (default) or on change/blur
- Display validation errors clearly
- Use appropriate validation rules (min, max, pattern, etc.)
- Provide helpful error messages

## Form State Management

- Track submission state (`isSubmitting`, `isLoading`)
- Track error state separately from validation errors
- Reset form after successful submission
- Disable form inputs during submission
- Show loading indicators during async operations

## File Uploads

- Handle file uploads separately from form submission
- Validate file types and sizes
- Show upload progress when possible
- Handle upload errors gracefully
- Preview uploaded files before submission

## Best Practices

- Use controlled components for form inputs
- Provide clear labels and placeholders
- Show validation errors inline
- Disable submit button during submission
- Reset form state after successful submission
- Handle both client and server-side validation
- Use proper form accessibility attributes
- Group related fields visually
- Show success feedback after submission
